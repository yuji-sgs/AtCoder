"""
N*M のグリッドがあり、この上にプレイヤーがいます。
このグリッドの上から i 行目、左から j 列目をマス (i,j) と書きます。
このグリッドの各マスは 氷 か 岩 であり、その情報は N 個の長さ M の文字列S1,S2,…,SNとして与えられます。
・もしSiのj 文字目が . なら、マス (i,j) は 氷 である。
・もしSiの j 文字目が # なら、マス (i,j) は 岩 である。
なお、このグリッドの外周 (1 行目、 N 行目、1 列目、 M 列目の全てのマス ) は 岩 です。

最初、プレイヤーはマス (2,2) の上で停止しています。このマスは 氷 です。
プレイヤーは以下の行動を 0 度以上何度でも行うことができます。

・まず、プレイヤーは上下左右の移動方向を指定する。
・その後、プレイヤーは岩のマスにぶつかるまでその方向に移動する。厳密には以下の通りである。
    ・もし移動方向に隣接するマスが 氷 なら、そのマスに移動し、同じ方向に移動を継続する。
    ・もし移動方向に隣接するマスが 岩 なら、今いるマスに留まり、移動を終了する。
    
プレイヤーが触れる (通過または上で停止する) ことができる 氷 の数を求めてください。
"""
# 再帰の深さ制限
import sys
sys.setrecursionlimit(10**8)
 
N, M = map(int, input().split())
S = [input() for _ in range(N)]

find = [[False] * M for _ in range(N)] # 探索が完了したマス
through = [[False] * M for _ in range(N)] # 通過したマス
 
# 深さ優先探索
def dfs(x, y):
    find[x][y] = True # 探索が完了したマスを記録
    for dx, dy in [(0, 1), (1, 0), (-1, 0), (0, -1)]:
        nx, ny = x, y
        # 一方向に移動する探索
        while S[nx+dx][ny+dy] != '#': # 壁にぶつかるまで移動
            nx += dx
            ny += dy
            through[nx][ny] = True
        if not find[nx][ny]: # 他の探索可能なマスがあれば再帰
            dfs(nx, ny)
 
through[1][1] = True
dfs(1, 1)
print(sum(sum(a) for a in through))


